'''
We have an array of non-negative integers. We can perform operations where, in each operation, 
we choose a number X > 0, and then subtract 1 from every element in the array that is >= X. 
This operation can be performed any number of times (including zero), and each operation's X can be chosen independently based on the current state of the array.

Our goal is to determine how many distinct arrays can be generated by performing any sequence of these operations on the initial array.

Given the example:
Initial array: [0, 1, 2, 3]

Some possible sequences of operations and resulting arrays:

Choose X=1: [0, 1-1, 2-1, 3-1] = [0, 0, 1, 2]

Choose X=2: [0, 1, 2-1, 3-1] = [0, 1, 1, 2]

Choose X=3: [0, 1, 2, 3-1] = [0, 1, 2, 2]

Choose X=2 then X=1:

After X=2: [0, 1, 1, 2]

Then X=1: [0, 1-1, 1-1, 2-1] = [0, 0, 0, 1]

Choose X=1, then X=2, then X=1:

After X=1: [0, 0, 1, 2]

Then X=2: [0, 0, 1, 2-1] = [0, 0, 1, 1]

Then X=1: [0, 0-1, 1-1, 1-1] = [0, 0, 0, 0] (Wait, no: elements are 0,0,1,1; X=1 subtracts from >=1, so indices 2,3: [0,0,0,0])

From these, the distinct arrays we've seen so far:

Original: [0,1,2,3]

[0,0,1,2]

[0,1,1,2]

[0,1,2,2]

[0,0,0,1]

[0,0,0,0]

[0,0,1,1] (from X=1 then X=2)

That's 7 distinct arrays. The problem states that these are all possible, so the answer is 7 for this example.

'''

def count_possible_arrays_exclude_original(arr):
    if not arr:
        return 0
    arr.sort()
    total = 1
    prev = 0  # a_0 is treated as 0
    for num in arr:
        diff = num - prev
        total *= (diff + 1)
        prev = num
    return total - 1  
# Example usage:
arr = [0, 1, 2, 3]
print(count_possible_arrays_exclude_original(arr))  # Output: 7